# 反转链表

## 反转链表 - 迭代法

```javascript
// 定义链表节点类
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// 反转链表 - 迭代法
function reverseList(head) {
    let prev = null;    // 前一个节点，初始为 null
    let current = head; // 当前节点，从头开始

    while (current !== null) {
        let next = current.next; // 保存下一个节点
        current.next = prev;     // 反转指针
        prev = current;          // 前移 prev
        current = next;          // 前移 current
    }

    return prev; // 返回新的头节点
}

// 测试代码
function createList(arr) {
    if (!arr.length) return null;
    let head = new ListNode(arr[0]);
    let current = head;
    for (let i = 1; i < arr.length; i++) {
        current.next = new ListNode(arr[i]);
        current = current.next;
    }
    return head;
}

function printList(head) {
    let result = [];
    let current = head;
    while (current !== null) {
        result.push(current.val);
        current = current.next;
    }
    console.log(result.join(" -> "));
}

// 测试用例
let list = createList([1, 2, 3, 4, 5]);
console.log("原始链表:");
printList(list); // 1 -> 2 -> 3 -> 4 -> 5
let reversedList = reverseList(list);
console.log("反转后链表:");
printList(reversedList); // 5 -> 4 -> 3 -> 2 -> 1
```

## 反转链表 - 递归法

```javascript
// 定义链表节点类（同上）
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// 反转链表 - 递归法
function reverseList(head) {
    // 递归终止条件：空链表或只有一个节点
    if (head === null || head.next === null) {
        return head;
    }

    // 递归反转剩余部分
    let newHead = reverseList(head.next);
    
    // 调整当前节点的指针
    head.next.next = head; // 将下一个节点的 next 指向当前节点
    head.next = null;      // 当前节点的 next 置为 null

    return newHead; // 返回新的头节点
}

// 测试代码（同上）
function createList(arr) {
    if (!arr.length) return null;
    let head = new ListNode(arr[0]);
    let current = head;
    for (let i = 1; i < arr.length; i++) {
        current.next = new ListNode(arr[i]);
        current = current.next;
    }
    return head;
}

function printList(head) {
    let result = [];
    let current = head;
    while (current !== null) {
        result.push(current.val);
        current = current.next;
    }
    console.log(result.join(" -> "));
}

// 测试用例
let list = createList([1, 2, 3, 4, 5]);
console.log("原始链表:");
printList(list); // 1 -> 2 -> 3 -> 4 -> 5
let reversedList = reverseList(list);
console.log("反转后链表:");
printList(reversedList); // 5 -> 4 -> 3 -> 2 -> 1
```

# 根据前序中序还原二叉树

问题描述：
给定二叉树的前序遍历（preorder）和中序遍历（inorder），重建唯一的二叉树并返回其根节点。  

- 前序遍历：根 -> 左 -> 右  
- 中序遍历：左 -> 根 -> 右

思路：  

- 前序遍历的第一个元素是根节点。
- 在中序遍历中找到根节点位置，左侧是左子树，右侧是右子树。
- 递归地对左子树和右子树进行相同操作。

```
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function buildTreeFromPreIn(preorder, inorder) {
    // 创建中序遍历值到索引的映射，提升查找效率
    const inorderMap = new Map();
    for (let i = 0; i < inorder.length; i++) {
        inorderMap.set(inorder[i], i);
    }

    // 递归构建函数
    function build(preStart, preEnd, inStart, inEnd) {
        if (preStart > preEnd) return null; // 边界条件：子树为空

        // 前序第一个元素是根节点
        const rootVal = preorder[preStart];
        const root = new TreeNode(rootVal);

        // 在中序中找到根节点位置
        const rootIndex = inorderMap.get(rootVal);
        const leftSize = rootIndex - inStart; // 左子树的大小

        // 递归构建左子树
        root.left = build(
            preStart + 1,              // 前序左子树起始
            preStart + leftSize,       // 前序左子树结束
            inStart,                   // 中序左子树起始
            rootIndex - 1              // 中序左子树结束
        );

        // 递归构建右子树
        root.right = build(
            preStart + leftSize + 1,   // 前序右子树起始
            preEnd,                    // 前序右子树结束
            rootIndex + 1,             // 中序右子树起始
            inEnd                      // 中序右子树结束
        );

        return root;
    }

    return build(0, preorder.length - 1, 0, inorder.length - 1);
}

// 测试代码
const preorder = [3, 9, 20, 15, 7];
const inorder = [9, 3, 15, 20, 7];
const tree = buildTreeFromPreIn(preorder, inorder);

// 验证：中序遍历输出
function inOrder(node) {
    if (node) {
        inOrder(node.left);
        console.log(node.val);
        inOrder(node.right);
    }
}
console.log("中序遍历验证:");
inOrder(tree); // 输出: 9, 3, 15, 20, 7
```

解释：

- 输入：preorder = [3, 9, 20, 15, 7], inorder = [9, 3, 15, 20, 7]。

- 过程：

  1. 前序第一个元素 3 是根节点。
  2. 在中序 [9, 3, 15, 20, 7] 中，3 左侧 [9] 是左子树，右侧 [15, 20, 7] 是右子树。
  3. 递归：
     - 左子树：前序 [9]，中序 [9] -> 节点 9。
     - 右子树：前序 [20, 15, 7]，中序 [15, 20, 7] -> 根 20，左 15，右 7。

- 结果树：

  ```text
     3
    / \
   9  20
      / \
     15  7
  ```

- 复杂度：

  - 时间：O(n)，使用 Map 优化查找。
  - 空间：O(n)，Map 和递归栈。

# 根据中序后序还原二叉树

问题描述：
给定二叉树的中序遍历（inorder）和后序遍历（postorder），重建唯一的二叉树并返回其根节点。  

- 中序遍历：左 -> 根 -> 右  
- 后序遍历：左 -> 右 -> 根

思路：  

- 后序遍历的最后一个元素是根节点。
- 在中序遍历中找到根节点位置，左侧是左子树，右侧是右子树。
- 递归地对左子树和右子树进行相同操作



```
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function buildTreeFromInPost(inorder, postorder) {
    // 创建中序遍历值到索引的映射
    const inorderMap = new Map();
    for (let i = 0; i < inorder.length; i++) {
        inorderMap.set(inorder[i], i);
    }

    // 递归构建函数
    function build(inStart, inEnd, postStart, postEnd) {
        if (inStart > inEnd) return null; // 边界条件：子树为空

        // 后序最后一个元素是根节点
        const rootVal = postorder[postEnd];
        const root = new TreeNode(rootVal);

        // 在中序中找到根节点位置
        const rootIndex = inorderMap.get(rootVal);
        const leftSize = rootIndex - inStart; // 左子树的大小

        // 递归构建左子树
        root.left = build(
            inStart,                   // 中序左子树起始
            rootIndex - 1,             // 中序左子树结束
            postStart,                 // 后序左子树起始
            postStart + leftSize - 1   // 后序左子树结束
        );

        // 递归构建右子树
        root.right = build(
            rootIndex + 1,             // 中序右子树起始
            inEnd,                     // 中序右子树结束
            postStart + leftSize,      // 后序右子树起始
            postEnd - 1                // 后序右子树结束
        );

        return root;
    }

    return build(0, inorder.length - 1, 0, postorder.length - 1);
}

// 测试代码
const inorder2 = [9, 3, 15, 20, 7];
const postorder = [9, 15, 7, 20, 3];
const tree2 = buildTreeFromInPost(inorder2, postorder);

// 验证：中序遍历输出
function inOrder(node) {
    if (node) {
        inOrder(node.left);
        console.log(node.val);
        inOrder(node.right);
    }
}
console.log("中序遍历验证:");
inOrder(tree2); // 输出: 9, 3, 15, 20, 7
```

解释：

- 输入：inorder = [9, 3, 15, 20, 7], postorder = [9, 15, 7, 20, 3]。

- 过程：

  1. 后序最后一个元素 3 是根节点。
  2. 在中序 [9, 3, 15, 20, 7] 中，3 左侧 [9] 是左子树，右侧 [15, 20, 7] 是右子树。
  3. 递归：
     - 左子树：中序 [9]，后序 [9] -> 节点 9。
     - 右子树：中序 [15, 20, 7]，后序 [15, 7, 20] -> 根 20，左 15，右 7。

- 结果树：

  ```text
     3
    / \
   9  20
      / \
     15  7
  ```

- 复杂度：

  - 时间：O(n)，使用 Map 优化查找。
  - 空间：O(n)，Map 和递归栈。

  关键点对比

  | 特性         | 前序 + 中序        | 中序 + 后序        |
  | ------------ | ------------------ | ------------------ |
  | 根节点位置   | 前序第一个         | 后序最后一个       |
  | 分区依据     | 中序中的根节点索引 | 中序中的根节点索引 |
  | 递归范围计算 | 前序划分左右子树   | 后序划分左右子树   |
  | 结果         | 相同的二叉树       | 相同的二叉树       |

# 二叉树的深度优先算法

# 二叉树的广度优先算法

